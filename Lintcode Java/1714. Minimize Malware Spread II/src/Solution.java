import java.util.*;

public class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        boolean[] dirty = new boolean[n];
        for (int i : initial) {
            dirty[i] = true;
        }
        
        int[] colors = new int[n];
        Arrays.fill(colors, -1);
        int color = 0;
        for (int i = 0; i < n; i++) {
            if (!dirty[i] && colors[i] == -1) {
                dfs(i, color++, colors, graph, dirty);
            }
        }
        
        int[] size = new int[color];
        for (int i : colors) {
            if (i != -1) {
                size[i]++;
            }
        }
        
        List<Integer>[] infectBy = (List<Integer>[]) new ArrayList[color];
        for (int i = 0; i < infectBy.length; i++) {
            infectBy[i] = new ArrayList<>();
        }
        
        for (int i : initial) {
            for (int j = 0; j < graph[i].length; j++) {
                if (!dirty[j] && graph[i][j] == 1) {
                    infectBy[colors[j]].add(i);
                }
            }
        }
        
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < infectBy.length; i++) {
            List<Integer> list = infectBy[i];
            if (list.size() == 1) {
                int s = list.get(0);
                map.put(s, map.getOrDefault(s, 0) + size[i]);
            }
        }
        
        int res = -1, maxCount = 0;
        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
            int s = entry.getKey(), count = entry.getValue();
            if (count > maxCount) {
                maxCount = count;
                res = s;
            } else if (count >= maxCount) {
                res = Math.min(res, s);
            }
        }
        
        if (res == -1) {
            res = n;
            for (int i : initial) {
                res = Math.min(res, i);
            }
        }
        
        return res;
    }
    
    private void dfs(int v, int color, int[] colors, int[][] graph, boolean[] dirty) {
        colors[v] = color;
        for (int i = 0; i < graph[v].length; i++) {
            if (!dirty[i] && graph[v][i] == 1 && colors[v] == -1) {
                dfs(i, color, colors, graph, dirty);
            }
        }
    }
}
